---
title: "Git A Grip: Handling Version-Control Nightmares"
image: "/hero-images/unsplash-github.jpg"
author: "Max Weekley"
date: "9-25-2025"
tags: ["Dev Journal", "Git"]
excerpt: >
    Be wary, for if you gaze long enough into the commit history, the commit history also gazes into you.
---

Today I was supposed to clean up the gaps in functionality and, if everything went well, 
launch my new react blog. For the most part this was mundane tasks like updating pictures, 
copy, and navigation routes. There were a couple of issues I needed to resolve before 
publishing my cool site to the internet, though.  

First, I was currently working out of two repositories. 
One repository hosted my GitHub Pages and was currently filled with code from my 
old website, and the other repository held all of my react code I had been working on for 
the last month. I needed to find a way to migrate my react code into the new database, and 
then I needed to take the old code and add it as a project showcase. At the end it needed 
to look something like this:  
<br />
```plaintext
<!-- New Code, Migrated to Github Pages Repo -->
react-blog
├─public
│	└─portfolio-projects
│		 	├─project-one
│           │   └─project-code
│           │ 
│		 	├─project-two
│           │   └─project-code
│           │ 
│		 	└─project-three
│		    	└─project-code <!-- We wanted our old code here -->
└─src

```
<br />
The other issue was a matter of deployment. I'd never hosted a react project myself, 
and I wanted an easy way to build and deploy from the same project. Since I'm used to 
using static files where the dist folder is basically just the project folder, I didn't 
really have a frame of reference for what to do here.  

First I did some research on GitHub Actions. I hadn't used it before today, but it's a 
really cool and robust feature. Unfortunately that's an entire separate post, for now all 
you need to know is I created a script do deploy my react code in GitHub and then jumped 
into our codebase migration issue. (just know this'll be relevant later.) 
<br /> 

## "What's The Worst That Could Happen?"
<br />

After considering a solution for a dangerously short amount of time, I decided the quickest 
and most painless solution would be a classic copy/paste procedure. I just needed to 
CTRL + X my old code, then CTRL + V it inside my react project. From there I could simply 
drag the files into the empty GitHub Pages repo. I knew going into this it was a crude 
solution, but since it was a small private project I thought to myself, "What's the worst 
that could happen?"  

As it turns out, the worst was pretty bad. First I was startled by my codebase syncing 
over 10K+ changes. That being said, this was still expected behavior. Since we migrated 
the original code files somewhere else it makes sense itd want to delete and rebuild them. 
After commiting, though, I was met with a much bigger issue. Each file contained merge 
conflicts. When I tried to resolve them I was given errors because the files no longer 
existed. This was where I started to panic. Massive broken commits, ghost merges, 
seemingly duplicated files in the commit logs, it was all too much to try and figure out 
at once. While I wanted to keep frenetically clicking and typing, I knew I had to take a 
step back and make sure I understood the full scope of the issue before continuing.  

That's when I remembered I'd experienced something similar before, and it all boils down 
to a little quirk regarding git that completely skipped my mind.  

<br />
## Understanding Git and Your Repositories
<br />

First we have to unpack how Git keeps track of code. Whenever you clone a repository to 
your computer, git needs to know where to find it so it can track your changes for you as 
well as metadata and commit history . How git handles this is by adding a little file 
folder called .git to your repository folder. You can think of it like microchipping your 
pet. Now, no matter where your folder goes it can keep track of it and the related 
information when something happens. Another fun fact about this folder is that in most 
IDE's it's hidden from view. To find it you need to open it up in your file explorer.

<br />
## Merge Conflicts and The Folly of Man's Hubris
<br />

So coming back to our code problem, we can finally understand the monstrosity 
I had created and reveal the harrowing truth. My repository had become two repositories. 
In my hubris, I had haphazardly copy/pasted my way to Frankenstein's Monster. 
I had inadvertently fused their souls, playing god and ultimately paying the price. 
Since my repository contained both a .git folder from the old code and another from the 
new code, Git saw something like this:  
<br />
```diff

- old-code
-    ├─index.html
-    ├─main.css
-    ├─main.js
-    ├─about
-    │	├─about.html
-    │	├─about.css
-    │	└─about.js
-    └─projects
-    	├─projects.html
-    	├─projects.css
-    	└─projects.js
+ react-blog
+    ├─public
+    │	└─portfolio-projects
+    │		 	├─project-one
+    │		    │	└─project-code
+    │		 	├─project-two
+    │		    │	└─project-code
+    │		 	└─project-three
+    │               └─ old-code
+    │                   ├─index.html
+    │                   ├─main.css
+    │                   ├─main.js
+    │                   ├─about
+    │                   │	├─about.html
+    │                   │	├─about.css
+    │                   │	└─about.js
+    │                   └─projects
+    │                   	├─projects.html
+    │                   	├─projects.css
+    │                   	└─projects.js
+    │
+    │
+    └─src

```
<br />
If we look at the example above, we start to get a better idea of what's going on. 
10K changes were deployed because it was two codebases it was tracking changes for, and in 
migrating the code it was deleting everything and replacing it in both places. But what 
about the ghost merge conflicts? What caused this?
Well, this is something I had to autopsy after the fact. Remember how I mentioned I created 
a GitHub Actions Script? Well, since I developed this website on one device by myself, I 
never had to pull changes from my repository during it's development. Unfortunately it 
skipped my mind that I'd need to pull changes to get my GitHub Actions script, causing the 
branch to be out-of-date right before I made these massive layout changes. Basically, I 
had made my branch out of date with the remote and then immediately proceeded to make my 
repositories unrecognizable, and as you'd expect chaos ensued.  
<br />

## Doing Damage Control
<br />

In my panic, my knee-jerk reaction was to try and run git rebase to try and lay my changes 
on top of the changes I was missing. The issue with this is that every file on the remote 
was deleted by my local changes. So again we were running into the wall of 'resolving 
conflicts by modifying code inside files that don't exist.'  
<br />
```bash
git merge --abort #This rewinds to just before we committed merge conflicts
git pull --rebase origin main #Trying to overlay our layout changes on the remote branch
```
<br />
I want to leave a quick disclaimer before we continue. This was the point in the process 
where I had already backed up my code and was prepared to resort to nuclear options. If 
you're working in a professional setting this is likely NOT the way to go. I only made 
these choices because it was a small project that only I had to worry about.
With that out of the way, lets continue.  

After backing out of our rebase, I decided I was going to erase all of my local changes 
with a hard reset:  
<br />
```bash
git reset --hard origin/main #hard reset, wipes all tracked files to the last commit
git clean -fd #removes any untracked files
```
<br />
Finally, I opened up the old code I had backed up, removed the .git folder, and copied it in.
While this worked in the end, it was far from the ideal solution. So what should you do to 
avoid running into the same mistakes I did?  
<br />

## On Avoiding My Mistakes
<br />

The first improvement is more of a mindset shift than anything. While it's a developer's 
job to design solutions and fix problems, it's important to remember that some solutions 
need time. When you see over 10K+ file changes and get errors everywhere, you need to learn 
to take your hands off of the keyboard and breathe. Is it scary? Absolutely. But the 
easiest way to make a bad situation worse is to act out of a sense of panic and urgency. 
Take a second to ask yourself why it's happening, and what measures you can take to minimize 
damage. Once you've adequately assessed what you're dealing with then you can act. You might 
need 15-30 minutes, but that time can save days worth of work.  

Next, respect your version control. Playing around with Git commands is similar to playing with 
fire. In my opinion, I think this is one of the reasons juniors don't get proper exposure to it. 
Yes, it's intimidating. No, no one likes working in the terminal. That being said, knowing it 
is vital to ensuring that you're safely contributing to a codebase. (Also, it's just kind of 
cool to be the guy that comes in and saves the day when everyone's sweating bullets over a 
diff that's five pages long.)
And more importantly, DON'T COMMIT CODE TO MAIN. Any developer working on a team will tell 
you this, and its mostly because it's the easiest way to run yourself into these issues. If 
you create a separate branch you can manage git issues in Github and they're separated into 
pull requests that make it significantly easier to protect your production code. If you take 
nothing else away from this post, just create a working branch, you'll thank me later.  

The other thing you can do is pull code in through a command like git subtree. Stuff like 
this is more advanced git commands, but it'd look something like this:  
<br />
```bash
git subtree add --prefix=<path/to/subtree> <repository_url> <remote_branch> --squash
```
<br />
This imports code from another repository into the one you're currently working out of. 
the --squash flag is important to avoid more massive diffs (since it condenses commit 
history from the project it's importing) but otherwise can be a pretty clean solution.  

Moving forward, I'm going to keep this advice in mind for when I run into these kinds of 
issues. While I've always worked well under pressure, it's not an excuse to allow these 
high-pressure issues to occur. I thought that since I was working alone I could handle 
whatever was thrown my way, but as I add features to this blog I want to be more intentional 
about how I personally use git to make the repo as a whole cleaner and easier to manage.
